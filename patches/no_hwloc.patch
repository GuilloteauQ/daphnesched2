diff --git a/build.sh b/build.sh
index cee3b627..ddaac9e6 100755
--- a/build.sh
+++ b/build.sh
@@ -614,29 +614,6 @@ if [ $WITH_DEPS -gt 0 ]; then
         daphne_msg "No need to build PAPI again."
     fi
 
-    #------------------------------------------------------------------------------
-    # hwloc
-    #------------------------------------------------------------------------------
-    hwlocDirName="hwloc-$hwlocVersion"
-    hwlocTarName="${hwlocDirName}.tar.gz"
-    hwlocInstDirName=$installPrefix
-    if ! is_dependency_downloaded "hwloc_v${hwlocVersion}"; then
-        daphne_msg "Get hwloc version ${hwlocVersion}"
-        wget "https://download.open-mpi.org/release/hwloc/v2.9/${hwlocTarName}" \
-            -qO "${cacheDir}/${hwlocTarName}"
-        tar -xf "$cacheDir/$hwlocTarName" -C "$sourcePrefix"
-        dependency_download_success "hwloc_v${hwlocVersion}"
-    fi
-    if ! is_dependency_installed "hwloc_v${hwlocVersion}"; then
-        cd "$sourcePrefix/$hwlocDirName/"
-        ./configure --prefix="$hwlocInstDirName"
-        make -j"$(nproc)" DYNAMIC_ARCH=1 TARGET="$PAPI_OBLAS_ARCH"
-        make install
-        cd - > /dev/null
-        dependency_install_success "hwloc_v${hwlocVersion}"
-    else
-        daphne_msg "No need to build hwloc again."
-    fi
 
     #------------------------------------------------------------------------------
     # #8.1 Antlr4 (parser)
diff --git a/src/runtime/local/kernels/CMakeLists.txt b/src/runtime/local/kernels/CMakeLists.txt
index 58841a56..3936abed 100644
--- a/src/runtime/local/kernels/CMakeLists.txt
+++ b/src/runtime/local/kernels/CMakeLists.txt
@@ -115,6 +115,5 @@ list(APPEND LIBS DaphneMetaDataParser MLIRDaphne MLIRDaphneTransforms)
 list(APPEND LIBS Eigen3::Eigen Arrow::arrow_shared Parquet::parquet_shared)
 
 find_library(PAPI_LIB NAMES libpapi.so HINTS ${PROJECT_BINARY_DIR}/installed/lib REQUIRED)
-find_library(HWLOC_LIB NAMES libhwloc.so HINTS ${PROJECT_BINARY_DIR}/installed/lib REQUIRED)
 
-target_link_libraries(AllKernels PUBLIC ${LIBS} ${MPI_LIBRARIES} ${PAPI_LIB} ${HWLOC_LIB})
+target_link_libraries(AllKernels PUBLIC ${LIBS} ${MPI_LIBRARIES} ${PAPI_LIB})
diff --git a/src/runtime/local/vectorized/MTWrapper.h b/src/runtime/local/vectorized/MTWrapper.h
index 73be9577..16716218 100644
--- a/src/runtime/local/vectorized/MTWrapper.h
+++ b/src/runtime/local/vectorized/MTWrapper.h
@@ -33,8 +33,6 @@
 #include <queue>
 #include <set>
 
-#include <hwloc.h>
-
 //TODO use the wrapper to cache threads
 //TODO generalize for arbitrary inputs (not just binary)
 
@@ -49,6 +47,7 @@ protected:
     std::vector<int> topologyPhysicalIds;
     std::vector<int> topologyUniqueThreads;
     std::vector<int> topologyResponsibleThreads;
+    std::string _cpuinfoPath = "/proc/cpuinfo";
     size_t _numThreads{};
     uint32_t _numCPPThreads{};
     uint32_t _numCUDAThreads{};
@@ -73,52 +72,58 @@ protected:
         return std::make_pair(len, mem_required);
     }
 
-    void hwloc_recurse_topology(hwloc_topology_t topo, hwloc_obj_t obj,
-                                unsigned int parent_package_id,
-                                std::vector<int>& physicalIds,
-                                std::vector<int>& uniqueThreads,
-                                std::vector<int>& responsibleThreads) {
-        if (obj->type != HWLOC_OBJ_CORE) {
-          for (unsigned int i = 0; i < obj->arity; i++) {
-              hwloc_recurse_topology(topo, obj->children[i], parent_package_id, physicalIds, uniqueThreads, responsibleThreads);
-          }
-        } else {
-          physicalIds.push_back(parent_package_id);
-          for (unsigned int i = 0; i < obj->arity; i++)
-            uniqueThreads.push_back(obj->children[i]->os_index);
-
-          switch (_ctx->getUserConfig().queueSetupScheme) {
-            case CENTRALIZED: {
-              responsibleThreads.push_back(0);
-            } break;
-            case PERGROUP: {
-              if (responsibleThreads.size() == parent_package_id)
-                responsibleThreads.push_back(obj->children[0]->os_index);
-            } break;
-            case PERCPU: {
-              responsibleThreads.push_back(obj->os_index);
-            } break;
-          }
+    bool _parseStringLine(const std::string& input, const std::string& keyword, int *val ) {
+        auto seperatorLocation = input.find(':');
+        if(seperatorLocation != std::string::npos) {
+            if(input.find(keyword) == 0) {
+                *val = stoi(input.substr(seperatorLocation + 1));
+                return true;
+            }
         }
+        return false;
     }
 
+    // FIXME: This method is not working on ARM - see GitHub issue [DAPHNE-#554]
     void get_topology(std::vector<int> &physicalIds, std::vector<int> &uniqueThreads, std::vector<int> &responsibleThreads) {
-        hwloc_topology_t topology;
-
-        hwloc_topology_init(&topology);
-        hwloc_topology_load(topology);
-
-        hwloc_obj_t package = hwloc_get_next_obj_by_type(topology, HWLOC_OBJ_PACKAGE, NULL);
-
-        while (package != NULL) {
-          auto package_id = package->os_index;
-          hwloc_recurse_topology(topology, package, package_id, physicalIds, uniqueThreads, responsibleThreads);
-          package = hwloc_get_next_obj_by_type(topology, HWLOC_OBJ_PACKAGE, package);
+        std::ifstream cpuinfoFile(_cpuinfoPath);
+        std::vector<int> utilizedThreads;
+        std::vector<int> core_ids;
+        int index = 0;
+        if( cpuinfoFile.is_open() ) {
+            std::string line;
+            int value;
+            while ( std::getline(cpuinfoFile, line) ) {
+                if( _parseStringLine(line, "processor", &value ) ) {
+                    utilizedThreads.push_back(value);
+                } else if( _parseStringLine(line, "physical id", &value) ) {
+                    if ( _ctx->getUserConfig().queueSetupScheme == PERGROUP ) {
+                        if (std::find(physicalIds.begin(), physicalIds.end(), value) == physicalIds.end()) {
+                            responsibleThreads.push_back(utilizedThreads[index]);
+                        }
+                    }
+                    physicalIds.push_back(value);
+                } else if( _parseStringLine(line, "core id", &value) ) {
+                    int found = 0;
+                    for (int i=0; i<index; i++) {
+                        if (core_ids[i] == value && physicalIds[i] == physicalIds[index]) {
+                                found++;
+                        }
+                    }
+                    core_ids.push_back(value);
+                    if( _ctx->config.hyperthreadingEnabled || found == 0 ) {
+                        uniqueThreads.push_back(utilizedThreads[index]);
+                        if ( _ctx->getUserConfig().queueSetupScheme == PERCPU ) {
+                            responsibleThreads.push_back(value);
+                        } else if ( _ctx->getUserConfig().queueSetupScheme == CENTRALIZED ) {
+                            responsibleThreads.push_back(0);
+                        }
+                    }
+                    index++;
+                }
+            }
+            cpuinfoFile.close();
         }
-
-        hwloc_topology_destroy(topology);
     }
-
     void initCPPWorkers(std::vector<TaskQueue *> &qvector, uint32_t batchSize, const bool verbose = false,
             int numQueues = 0, int queueMode = 0, bool pinWorkers = false) {
         cpp_workers.resize(_numCPPThreads);
@@ -182,9 +187,19 @@ protected:
 
 public:
     explicit MTWrapperBase(uint32_t numFunctions, DCTX(ctx)) : _ctx(ctx) {
-        _ctx->logger->debug("Querying cpu topology");
+        // ToDo: this is a workaround until getTopology() is properly fixed via hwloc library calls (see issue [DAPHNE-#554])
+#ifdef __x86_64__
+        _ctx->logger->debug("Querying x86-64 cpu topology");
         get_topology(topologyPhysicalIds, topologyUniqueThreads, topologyResponsibleThreads);
-
+#else
+        _ctx->logger->debug("Querying arm cpu topology");
+        _numCPPThreads = std::thread::hardware_concurrency();
+        for (auto i = 0; i < static_cast<int>(_numCPPThreads); i++) {
+            topologyPhysicalIds.push_back(i);
+            topologyUniqueThreads.push_back(i);
+            topologyResponsibleThreads.push_back(i);
+        }
+#endif
         if(ctx->config.numberOfThreads > 0)
             _numCPPThreads = ctx->config.numberOfThreads;
         else
